"use strict";(self.webpackChunkscanamo_website=self.webpackChunkscanamo_website||[]).push([[118],{2756:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>m});var t=n(4848),o=n(8453);const r={title:"DynamoFormat",sidebar_position:6},s=void 0,i={id:"dynamo-format",title:"DynamoFormat",description:"Scanamo uses the DynamoFormat type class to define how to read and write different types to DynamoDB.",source:"@site/docs/dynamo-format.md",sourceDirName:".",slug:"/dynamo-format",permalink:"/dynamo-format",draft:!1,unlisted:!1,editUrl:"https://github.com/scanamo/scanamo/blob/main/docs/dynamo-format.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"DynamoFormat",sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Using Indexes",permalink:"/using-indexes"}},c={},m=[{value:"Automatic Derivation",id:"automatic-derivation",level:3},{value:"Semi-automatic Derivation",id:"semi-automatic-derivation",level:3},{value:"Custom Formats",id:"custom-formats",level:3},{value:"Formats for Refined Types",id:"formats-for-refined-types",level:3},{value:"Derived Formats",id:"derived-formats",level:3}];function l(e){const a={a:"a",code:"code",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(a.p,{children:["Scanamo uses the ",(0,t.jsx)(a.code,{children:"DynamoFormat"})," type class to define how to read and write different types to DynamoDB."]}),"\n",(0,t.jsxs)(a.p,{children:["Many common types have a ",(0,t.jsx)(a.code,{children:"DynamoFormat"})," provided by Scanamo. For a full list see of those supported, you can look at the companion object."]}),"\n",(0,t.jsxs)(a.p,{children:["Scanamo also supports automatically deriving formats for case classes and sealed trait families where all the contained types have a defined or derivable ",(0,t.jsx)(a.code,{children:"DynamoFormat"}),"."]}),"\n",(0,t.jsx)(a.h3,{id:"automatic-derivation",children:"Automatic Derivation"}),"\n",(0,t.jsxs)(a.p,{children:["Scanamo can automatically derive ",(0,t.jsx)(a.code,{children:"DynamoFormat"})," for case classes (as long as all its members can also be derived). Ex:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-scala",children:'import org.scanamo._\nimport org.scanamo.generic.auto._\n\ncase class Farm(animals: List[String])\ncase class Farmer(name: String, age: Long, farm: Farm)\n\nval table = Table[Farmer]("farmer")\ntable.putAll(\n    Set(\n        Farmer("McDonald", 156L, Farm(List("sheep", "cow"))),\n        Farmer("Boggis", 43L, Farm(List("chicken")))\n    )\n)\n'})}),"\n",(0,t.jsx)(a.h3,{id:"semi-automatic-derivation",children:"Semi-automatic Derivation"}),"\n",(0,t.jsxs)(a.p,{children:["Scanamo offers a convenient way (semi-automatic) to derive ",(0,t.jsx)(a.code,{children:"DynamoFormat"})," in your code.\nEx:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-scala",children:"import org.scanamo._\nimport org.scanamo.generic.semiauto._\n\ncase class Farm(animals: List[String])\ncase class Farmer(name: String, age: Long, farm: Farm)\n\nimplicit val formatFarm: DynamoFormat[Farm] = deriveDynamoFormat\nimplicit val formatFarmer: DynamoFormat[Farmer] = deriveDynamoFormat\n"})}),"\n",(0,t.jsx)(a.h3,{id:"custom-formats",children:"Custom Formats"}),"\n",(0,t.jsxs)(a.p,{children:["It's also possible to define a serialisation format for types which Scanamo doesn't already support and can't derive. Normally this involves using the ",(0,t.jsx)(a.code,{children:"DynamoFormat.xmap"})," or ",(0,t.jsx)(a.code,{children:"DynamoFormat.coercedXmap"})," to translate between the type and one Scanamo does already know about."]}),"\n",(0,t.jsxs)(a.p,{children:["For example, to store Joda ",(0,t.jsx)(a.code,{children:"DateTime"})," objects as ISO ",(0,t.jsx)(a.code,{children:"String"}),"s in Dynamo:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-scala",children:'import org.joda.time._\nimport org.scanamo._\nimport org.scanamo.generic.auto._\nimport software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType._\n\ncase class Foo(dateTime: DateTime)\n\nval client = LocalDynamoDB.syncClient()\n// client: software.amazon.awssdk.services.dynamodb.DynamoDbClient = software.amazon.awssdk.services.dynamodb.DefaultDynamoDbClient@6519463d\nval scanamo = Scanamo(client)\n// scanamo: Scanamo = org.scanamo.Scanamo@58633a6c\n\nLocalDynamoDB.createTable(client)("foo")("dateTime" -> S)\n// res3: software.amazon.awssdk.services.dynamodb.model.CreateTableResponse = CreateTableResponse(TableDescription=TableDescription(AttributeDefinitions=[AttributeDefinition(AttributeName=dateTime, AttributeType=S)], TableName=foo, KeySchema=[KeySchemaElement(AttributeName=dateTime, KeyType=HASH)], TableStatus=ACTIVE, CreationDateTime=2024-03-29T16:04:16.616Z, ProvisionedThroughput=ProvisionedThroughputDescription(LastIncreaseDateTime=1970-01-01T00:00:00Z, LastDecreaseDateTime=1970-01-01T00:00:00Z, NumberOfDecreasesToday=0, ReadCapacityUnits=1, WriteCapacityUnits=1), TableSizeBytes=0, ItemCount=0, TableArn=arn:aws:dynamodb:ddblocal:000000000000:table/foo, DeletionProtectionEnabled=false))\n\nimplicit val jodaStringFormat = DynamoFormat.coercedXmap[DateTime, String, IllegalArgumentException](\n  DateTime.parse(_).withZone(DateTimeZone.UTC),\n  _.toString\n)\n// jodaStringFormat: DynamoFormat[DateTime] = org.scanamo.DynamoFormat$$anon$4@70973e08\n\nval fooTable = Table[Foo]("foo")\n// fooTable: Table[Foo] = Table("foo")\n\nscanamo.exec {\n  for {\n    _           <- fooTable.put(Foo(new DateTime(0)))\n    results     <- fooTable.scan()\n  } yield results\n}.toList\n// res4: List[Either[DynamoReadError, Foo]] = List(\n//   Right(Foo(1970-01-01T00:00:00.000Z))\n// )\n'})}),"\n",(0,t.jsx)(a.h3,{id:"formats-for-refined-types",children:"Formats for Refined Types"}),"\n",(0,t.jsxs)(a.p,{children:["Scanamo supports Scala refined types via the ",(0,t.jsx)(a.code,{children:"scanamo-refined"})," module, helping you to define custom formats\nfor types built using the predicates provided by the ",(0,t.jsx)(a.a,{href:"https://github.com/fthomas/refined",children:"refined"})," project.\nRefined types give an extra layer of type safety to our programs making the compilation fail when we try to\nassign wrong values to them."]}),"\n",(0,t.jsx)(a.p,{children:"To use them in your project you will need to include the dependency in your project:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{children:'libraryDependencies += "org.scanamo" %% "scanamo-refined" % "x.y.z"\n'})}),"\n",(0,t.jsx)(a.p,{children:"And then import the support for refined types and define your model:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-scala",children:'import org.scanamo._\nimport eu.timepit.refined._\nimport eu.timepit.refined.api.Refined\nimport eu.timepit.refined.auto._\nimport eu.timepit.refined.numeric._\nimport software.amazon.awssdk.services.dynamodb.model.ScalarAttributeType._\n\nval client = LocalDynamoDB.syncClient()\nval scanamo = Scanamo(client)\n\ntype PosInt = Int Refined Positive\n\ncase class Customer(age: PosInt)\n\nLocalDynamoDB.createTable(client)("Customer")("age" -> N)\n'})}),"\n",(0,t.jsxs)(a.p,{children:["You just now use it like if the type ",(0,t.jsx)(a.code,{children:"PosInt"})," was natively supported by ",(0,t.jsx)(a.code,{children:"scanamo"}),":"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-scala",children:'import org.scanamo.refined._\nimport org.scanamo.generic.auto._\n\nval customerTable = Table[Customer]("Customer")\n// customerTable: Table[Customer] = Table("Customer")\nscanamo.exec {\n  for {\n    _       <- customerTable.put(Customer(67))\n    results <- customerTable.scan()\n  } yield results\n}.toList\n// res7: List[Either[DynamoReadError, Customer]] = List(Right(Customer(67)))\n'})}),"\n",(0,t.jsx)(a.h3,{id:"derived-formats",children:"Derived Formats"}),"\n",(0,t.jsxs)(a.p,{children:["Scanamo uses ",(0,t.jsx)(a.a,{href:"https://magnolia.work/opensource/magnolia",children:"magnolia"})," and implicit derivation to automatically derive ",(0,t.jsx)(a.code,{children:"DynamoFormat"}),"s for case classes and sealed trait families. You may also see or hear sealed trait families referred to as Algebraic Data Types (ADTs) and co-products. Here is an example that could be used to support event sourcing (assuming a table with a partition key of ",(0,t.jsx)(a.code,{children:"id"})," and sort key ",(0,t.jsx)(a.code,{children:"seqNo"}),"):"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-scala",children:'import java.util.UUID\n\nimport org.scanamo._\n\n// Sealed trait family for events.\nsealed trait Event\ncase class Create(name: String) extends Event\ncase class Delete(reason: String) extends Event\n\n// An event envelope that wraps events.\ncase class EventEnvelope(id: UUID, seqNo: Int, event: Event)\n\n// Example instantiations.\nval id = UUID.fromString("9e5fd6e9-65ef-472c-ad89-e5fe658f14c6")\nval create = EventEnvelope(id, 0, Create("Something"))\nval delete = EventEnvelope(id, 1, Delete("Oops"))\n'})}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-scala",children:'import org.scanamo._\nimport org.scanamo.generic.auto._\n\nval attributeValue = DynamoFormat[EventEnvelope].write(create)\n// attributeValue: DynamoValue = DynObject(\n//   Pure(\n//     Map(\n//       "event" -> DynObject(\n//         Pure(\n//           Map(\n//             "Create" -> DynObject(Pure(Map("name" -> DynString("Something"))))\n//           )\n//         )\n//       ),\n//       "seqNo" -> DynNum("0"),\n//       "id" -> DynString("9e5fd6e9-65ef-472c-ad89-e5fe658f14c6")\n//     )\n//   )\n// )\n\nval dynamoRecord = DynamoFormat[EventEnvelope].read(attributeValue)\n// dynamoRecord: Either[DynamoReadError, EventEnvelope] = Right(\n//   EventEnvelope(9e5fd6e9-65ef-472c-ad89-e5fe658f14c6, 0, Create("Something"))\n// )\n'})}),"\n",(0,t.jsx)(a.p,{children:"If you look carefully at the attribute value (pretty-printed below) then you can see that the envelope (or wrapper) is necessary. This is because Scanamo writes the sealed trait family and associated case classes into a map. This allows Scanamo to use the map key to disambiguate between the sub-classes when reading attribute values. This makes sense and works well for most use cases, but it does mean you cannot persist an sealed trait family directly (i.e. without an envelope or wrapper) using automatic derivation because partition keys do not support maps."}),"\n",(0,t.jsx)(a.p,{children:"Here is the pretty-printed attribute value that Scanamo generates:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-json",children:'{\n  "M": {\n    "seqNo": {\n      "N": 0\n    },\n    "id": {\n      "S": "9e5fd6e9-65ef-472c-ad89-e5fe658f14c6"\n    },\n    "event": {\n      "M": {\n        "Create": {\n          "M": {\n            "name":{\n              "S": "Something"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n'})})]})}function d(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>s,x:()=>i});var t=n(6540);const o={},r=t.createContext(o);function s(e){const a=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(r.Provider,{value:a},e.children)}}}]);